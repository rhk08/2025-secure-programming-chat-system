Distributed Peer-to-Peer Chat System (GPT Wrote this.)
====================================

Overview
--------
This system allows multiple servers on a LAN to coordinate a chat network with end-to-end
encryption. Clients connect to any server, which forwards messages and ensures global
username uniqueness across the network. Servers communicate with each other using a
defined peer-to-peer protocol.

Architecture
------------
       Client A ----\
                     \
       Client B -----> Server 1 ------> Server 2
       Client C ----/                  \
                                        Server 3

- Servers act as both:
  - Local chat server for connected clients.
  - Peer server to communicate with other servers for username checks and message forwarding.
- Clients only connect to one server, but the network ensures global username uniqueness and message delivery.

Server Discovery
----------------
1. UDP Broadcast:
   - Each server broadcasts "SERVER_DISCOVERY" on the LAN.
   - Other servers add the new server IP to their peer_servers list.

2. Client Discovery:
   - Client broadcasts "CHAT_DISCOVERY" when starting.
   - Servers respond with their WebSocket URI.
   - Client connects to the first server that responds.

Sign-In / Username Management
-----------------------------
1. Client sends a Sign-in request:
   {"type": "Sign-in", "content": "alice", "sender": "Guest", "public_key": "<PEM>"}

2. Server checks:
   - Local connected_clients: is "alice" free?
   - Peer servers via "username_check":
     {"type": "username_check", "content": "alice"}

3. Peers respond: {"available": true/false}

4. If all peers and local server confirm availability:
   - Username is accepted.
   - Added to connected_clients and client_public_keys.
   - Heartbeat tracking starts in client_last_seen.

Heartbeat & Disconnect Handling
-------------------------------
- Heartbeat interval: Server sends {"type": "heartbeat"} every HEARTBEAT_INTERVAL seconds.
- Client replies: {"type": "heartbeat_ack","sender":"alice"}.
- If no response within HEARTBEAT_TIMEOUT:
  - Server assumes client disconnected.
  - Calls cleanup_client(username).
  - Broadcasts disconnect to peers:
    {"type": "user_disconnected","content":"alice"}

Messaging Flow
--------------
Private Message:
1. Client encrypts message using recipientâ€™s public key (AES + RSA hybrid).
2. Sends to server:
   {
     "type": "chat",
     "recipient": "bob",
     "sender": "alice",
     "enc_aes_key": "...",
     "nonce": "...",
     "ciphertext": "...",
     "tag": "..."
   }
3. Server forwards to local client if available; otherwise forwards to peers.

Group Message: TODO
1. Set recipient: "Group".
2. Server sends to all local clients except sender.
3. Server forwards to all peers, which do the same.

Server-to-Server Protocol
-------------------------
| Type                   | Content / Description |
|------------------------|---------------------|
| SERVER_DISCOVERY       | UDP broadcast to announce server presence. |
| username_check         | {"type": "username_check", "content": "<username>"} |
| {"available": true/false} | Response to username_check indicating availability. |
| user_disconnected      | {"type": "user_disconnected", "content": "<username>"} |
| forward_chat / chat    | {"type":"chat","sender":"alice","recipient":"bob","payload":{...}} Forward encrypted chat to peer. |
| heartbeat              | {"type": "heartbeat"} Ping client to verify connection. |
| heartbeat_ack          | {"type": "heartbeat_ack","sender":"alice"} Client reply to heartbeat. |

Notes:
------
- All chat messages remain end-to-end encrypted; servers never see plaintext.
- The protocol is extensible: new message types can be added by including "type" and "content" fields.
- Username uniqueness is guaranteed across the LAN peer network.
- Servers propagate disconnect events to peers, freeing usernames for reuse.
- Clients discover servers dynamically and automatically respond to heartbeats.

